
### 🔍 일반적인 자료구조에서의 검색 방식

#### 예시: 연결 리스트(Linked List)

```plaintext
[10] -> [25] -> [43] -> [87] -> [56]
```

* 위 리스트에서 `87`을 찾기 위해서는 처음부터 하나씩 비교하면서 찾아야 함.
* 최악의 경우 O(n)의 시간이 걸림. (n: 전체 원소 개수)

#### 예시: 이진 탐색 트리(BST)

```
        50
       /  \
     30    70
    / \    / \
   20 40  60 80
```

* 정렬된 구조이기 때문에 이진 탐색을 통해 비교 횟수를 줄일 수 있음.
* 평균 시간 복잡도는 O(log n)이지만, 트리가 한쪽으로 치우치면 O(n)까지도 떨어질 수 있음.

---

### 🚀 해시테이블의 검색 방식

해시테이블은 다음과 같은 방식으로 동작:

#### 1. 키(key)에 해시 함수(hash function)를 적용

* 예: 키가 `"apple"`이라면 `hash("apple")` → 5 (예시)

#### 2. 결과값(해시값)을 배열의 인덱스로 사용

```plaintext
index:      0    1    2    3    4    5    6
           [ ]  [ ]  [ ]  [ ]  [ ] ["apple", 100]  [ ]
```

#### 3. 해당 인덱스의 위치에 바로 접근하여 데이터 확인

* `"apple"`이라는 키의 값을 찾고 싶을 때, 해시함수로 5라는 인덱스를 얻으면
* **단 한 번의 배열 접근으로 값(100)을 찾을 수있음.**
* 평균 시간 복잡도는 **O(1)**

---

### ✅ 예시로 비교해보기

#### 상황: 이름과 전화번호 목록에서 "홍길동"의 번호를 찾는다고 해보자.

**1. 배열 (리스트) 사용 시**

```plaintext
[("김철수", "010-1111-2222"),
 ("이영희", "010-2222-3333"),
 ("홍길동", "010-3333-4444")]
```

* "홍길동"이 어디에 있는지 하나하나 비교해야 함 → **최악의 경우 O(n)**

**2. 해시테이블 사용 시**

```python
{
  "김철수": "010-1111-2222",
  "이영희": "010-2222-3333",
  "홍길동": "010-3333-4444"
}
```

* `"홍길동"`이라는 키로 바로 접근 가능 → **O(1)**

---

### 📌 요약

| 자료구조   | 평균 검색 시간 | 방식                  |
| ------ | -------- | ------------------- |
| 배열/리스트 | O(n)     | 순차 탐색               |
| 트리     | O(log n) | 비교 기반 탐색            |
| 해시테이블  | **O(1)** | 키 → 해시값 → 배열 인덱스 접근 |

---

### 🔧 참고: 해시테이블도 완벽하진 않다

* 해시 충돌이 발생하면 검색 속도가 저하될 수 있음 → 충돌 해결 방식 필요 (예: 체이닝, 오픈 주소법)
* 메모리 공간을 넉넉히 잡아야 좋은 성능 유지 가능

---

## ✅ 해시테이블의 기본 연산 성능

| 연산 | 평균 시간 복잡도 | 설명                       |
| -- | --------- | ------------------------ |
| 검색 | O(1)      | 키 → 해시값 → 배열 인덱스로 바로 접근  |
| 삽입 | O(1)      | 빈 버킷이면 바로 삽입, 충돌 시 처리 필요 |
| 삭제 | O(1)      | 키로 바로 찾아서 삭제             |
| 수정 | O(1)      | 키로 찾은 후 값만 덮어씀           |

※ **이 모든 연산이 "키"를 기준으로 동작**하기 때문에 빠릅니다.
※ 단, \*\*충돌이 너무 많아지면 최악의 경우 O(n)\*\*까지 떨어질 수 있습니다.

---

## 🔍 다른 자료구조와 비교

### 1. **배열(Array) / 리스트(List)**

* **삽입:** O(1) (맨 뒤에 넣을 때만), 중간에 끼워 넣으면 O(n)
* **삭제:** O(n) (지운 후 요소들을 앞으로 당겨야 함)
* **수정:** O(1) (인덱스를 알고 있을 때)
* **검색:** O(n) (하나씩 비교)

### 2. **연결 리스트(Linked List)**

* **삽입/삭제:** O(1) (노드를 알고 있으면 빠름, 탐색은 필요)
* **검색:** O(n) (하나씩 따라가야 함)
* **수정:** O(n) (먼저 찾아야 하기 때문에)

### 3. **이진 탐색 트리(BST)**

* **검색/삽입/삭제:** O(log n) (균형 잡힌 경우)
* **최악의 경우:** O(n) (편향 트리일 때)

---

## 🧠 예시로 보기

```python
# 해시테이블 (Python dict)
phone_book = {
    "홍길동": "010-3333-4444",
    "이영희": "010-2222-3333"
}

# 삽입
phone_book["김철수"] = "010-1111-2222"  # O(1)

# 수정
phone_book["홍길동"] = "010-9999-9999"  # O(1)

# 삭제
del phone_book["이영희"]  # O(1)

# 검색
print(phone_book["홍길동"])  # O(1)
```

---

## ⚠️ 해시테이블의 단점도 있음

* **정렬된 순서로 저장되지 않음**

  * 순차 탐색이나 정렬이 필요한 경우엔 부적합
* **메모리를 많이 사용함**

  * 성능을 위해 빈 공간을 여유롭게 유지함
* **충돌이 많아질 경우 성능 저하**

  * 해시 함수 품질과 테이블 크기에 따라 성능 차이 큼

---

## ✅ 결론

| 작업 | 해시테이블 평균 시간 | 다른 자료구조 평균 시간        | 요약     |
| -- | ----------- | -------------------- | ------ |
| 검색 | O(1)        | 배열 O(n), 트리 O(log n) | 가장 빠름  |
| 삽입 | O(1)        | 배열 O(n), 리스트 O(1\~n) | 대부분 빠름 |
| 수정 | O(1)        | 배열/리스트는 O(n) 탐색 필요   | 빠름     |
| 삭제 | O(1)        | 배열 O(n), 리스트 O(n)    | 빠름     |

→ **정렬이나 순차 접근이 필요 없다면 해시테이블은 거의 모든 면에서 뛰어난 성능을 보입니다.**
